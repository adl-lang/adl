use std::{path::{Path, PathBuf}, collections::HashSet};
use std::{fs,io};
use std::io::{Write,BufRead};

pub struct TreeWriter {
    pub root_dir: PathBuf,
    pub manifest_file: Option<PathBuf>,
    pub manifest: Manifest,
}

impl TreeWriter {
    pub fn new(root_dir: PathBuf, manifest_file: Option<PathBuf>) -> io::Result<Self> {

        let manifest = HashSet::new();
        Ok(TreeWriter { root_dir, manifest_file, manifest})
    }

    /// Write a file to the specifed path, creating parent directories as required
    pub fn write(&mut self, path: &Path, content: String) -> io::Result<()> {
        let mut file_path = self.root_dir.clone();
        file_path.push(path);
        log::info!("writing {}", file_path.display());
        let dir_path = file_path.parent().unwrap();
        std::fs::create_dir_all(dir_path)?;
        std::fs::write(file_path, &content)?;

        self.manifest.insert(path.to_owned());
        Ok(())
    }

    pub fn close(&self) -> io::Result<()> {

        if let Some(to_file) = &self.manifest_file {

            // Read old manifest
            let old_manifest = 
                if to_file.exists() {
                    TreeWriter::read_manifest(to_file)?
                } else {
                    HashSet::new()
                };

            // Write the new one
            log::info!("writing manifest {}", to_file.display());
            TreeWriter::write_manifest(to_file, &self.manifest)?;

            // Remove any files left from the old manifest
            for f in old_manifest.difference(&self.manifest) {
                let mut file_path = self.root_dir.clone();
                file_path.push(f);
                log::info!("removing {}", file_path.display());
            }
        }
        Ok(())
    }

    fn read_manifest(from_file: &Path) -> io::Result<Manifest> {
        let file = fs::File::open(from_file)?;
        let lines = io::BufReader::new(file).lines();
        let mut manifest : Manifest = HashSet::new();
        for line in lines {
            let s = line?;
            let s = s.trim();
            if ! s.starts_with("#") {
                manifest.insert(PathBuf::from(s));
            }
        }
        Ok(manifest)
    }

    fn write_manifest(to_file: &Path, manifest: &Manifest) -> io::Result<()> {
        let dir_path = to_file.parent().unwrap();
        fs::create_dir_all(dir_path)?;
        let mut file = fs::OpenOptions::new()
            .write(true)
            .create(true)
            .open(to_file)?;
        file.write(b"# manifest @generated by the adl compiler\n")?;
        let mut manifest: Vec<&PathBuf> = manifest.into_iter().collect();
        manifest.sort();
        for m in manifest {
            file.write(m.to_str().unwrap().as_bytes())?;
            file.write(b"\n")?;
        }
        Ok(())
    }
}

impl Drop for TreeWriter {
    fn drop(&mut self) {
        self.close().unwrap();
    }
}


type Manifest = HashSet<PathBuf>;

